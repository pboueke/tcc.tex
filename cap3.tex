\section{Arquitetura}

\paragraph{}O projeto desenvolvido se trata de uma aplicação \textit{Django} que conta com três interfaces, uma para execução de um modelo preditivo em ocorrências controladas, outra para monitoramento dos serviços associados e outra para a visualização dos resultados das predições, chamadas, respectivamente, de \textit{Showroom}, \textit{Monitor} e \textit{Disparo}. Essas três interfaces são controladas pela aplicação por meio de três classes, vistas na figura 3.1. Os componentes da aplicação podem ser visualizados na figura 3.2, onde se observa a existência de um arquivo \textit{config.yaml}, responsável por agregar todos os parâmetros e configurações da aplicação.

Além da aplicação, existem as componentes \textit{daemon.py} e \textit{datalake.py} que são responsáveis, respectivamente, pela predição de resultados e conexão com o \textit{datalake} onde estão os dados a sofrerem predições. O escalonamento de predições é gerenciado pelo \textit{crontab}, que, por sua vez, é gerenciado pela aplicação.


\section{Implementação}

\paragraph{} No modelo seguido pelo \textit{framework Django}, o modelo \textit{MTV}, todas as páginas e interfaces da aplicação são renderizadas a partir de templates HTML preenchidos pelo controlador da aplicação, que no caso se trata do arquivo \textit{views.py}. Os templates HTML se encontram dentro do diretório \textit{templates}. Os modelos se encontram no arquivo \textit{models.py}, fazendo uso direto das classes de modelo do \textit{framework}. As rotas da aplicação se encontram no arquivo \textit{urls.py}. As componentes \textit{monitor.py}, \textit{showroom.py}, \textit{dispatch.py}, \textit{datalake.py} e \textit{daemon.py} se encontram no diretório \textit{scripts}.

\begin{figure}
\begin{center}
\parbox[htb]{13.0cm}
  {
  \begin{center}
  \includegraphics[scale=0.5]{framework_clases.png}
  \caption[\small{Diagrama de classes da aplicação.}]{\label{FigDel} \small{Diagrama de classes da aplicação.}}
  \end{center}
  }
\end{center}
\end{figure}

\begin{figure}
\begin{center}
\parbox[htb]{13.0cm}
  {
  \begin{center}
  \includegraphics[scale=0.50]{framework.png}
  \caption[\small{Diagrama de componentes da aplicação.}]{\label{FigDel} \small{Diagrama de componentes da aplicação.}}
  \end{center}
  }
\end{center}
\end{figure}

\subsection{Configuração}

\paragraph{}Toda a configuração da aplicação é feita a partir de dois arquivos, o \textit{settings.py} e o \textit{config.yaml}. No primeiro são configuradas as propriedades básicas de uma aplicação \textit{Django}, se tratando de seu arquivo de configuração padrão. No segundo, estão as configurações específicas a essa aplicação. O caminho ao arquivo \textit{config.yaml} é escrito como a variável \textit{CONFIG\_FILE}, dentro do arquivo \textit{settings.py}, para que as configurações possam ser carregadas na aplicação durante sua inicialização.

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
\begin{table}[]
\caption{Parâmetros de configuração contidos no arquivo \textit{config.yaml}.}
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|}
\hline
Parâmetro                                   & Descrição                                                                                                                                                                                     \\ \hline
monitor.controllerserver.address            & Endereço (ip ou nome de domínio) para o servidor monitorado                                                                                                                                   \\ \hline
monitor.controller.server.machanism         & \begin{tabular}[c]{@{}l@{}}Mecanismo de conexão  com o servidor monitorado (plain ou ssl para ips,\\  dns para nomes de domínio)\end{tabular}                                                 \\ \hline
monitor.controller.server.port              & Porta de conexão com o servidor monitorado(apenas para ips)                                                                                                                                   \\ \hline
monitor.view.refresh\_rate                  & Segundos entre atualizações das informaçoes na view monitor                                                                                                                                   \\ \hline
dispatch.view.filter.default\_offset        & Diferença temporal padrão para o filtro de disparos                                                                                                                                           \\ \hline
showroom.controller.max\_min\_model\_path   & Arquivo de modelo usado para pré-tratamento das amostras                                                                                                                                      \\ \hline
showroom.controller.prediction\_model\_path & Arquivo de modelo usado para a predição dos resultados                                                                                                                                        \\ \hline
showroom.controller.samples\_path           & Arquivo contendo amostras em formato csv                                                                                                                                                      \\ \hline
showroom.controller.number\_of\_columns     & Número de colunas entre as primeiras do arquivo a serem mostradas na view                                                                                                                     \\ \hline
mysql\_events\_db.name                      & Nome do banco de eventos                                                                                                                                                                      \\ \hline
mysql\_events\_db.user                      & Nome do usuário do banco de dados                                                                                                                                                             \\ \hline
mysql\_events\_db.password                  & Senha do usuário do banco de enventos                                                                                                                                                         \\ \hline
mysql\_events\_db.host                      & Endereço do banco de eventos                                                                                                                                                                  \\ \hline
mysql\_events\_db.port                      & Porta de acesso ao banco de eventos                                                                                                                                                           \\ \hline
datalake.connection\_string                 & Cadeia de conexão ODBC para o datalake                                                                                                                                                        \\ \hline
datalake.table                              & \begin{tabular}[c]{@{}l@{}}Nome de uma tabela (qualquer tabela existente) usada para verificar a\\  conexão com o banco\end{tabular}                                                          \\ \hline
daemon.user                                 & Nome do usuário do SO                                                                                                                                                                         \\ \hline
daemon.comment                              & Comentário usado como id único para a tarefa cron                                                                                                                                             \\ \hline
daemon.cron                                 & Expressão CRON para a execução do comando                                                                                                                                                     \\ \hline
daemon.venv                                 & \begin{tabular}[c]{@{}l@{}}Caminho para a ativação do virtual environment (opcional, usado caso \\ os pacotes requeridos pelo script daemon não estejam disponíveis globalmente)\end{tabular} \\ \hline
daemon.command                              & Comando a ser executado pelo daemon cron                                                                                                                                                      \\ \hline
daemon.log\_file                            & \begin{tabular}[c]{@{}l@{}}Arquivo log de depuração - deixe em branco se não estiver debugando, \\ o log será ignorado\end{tabular}                                                           \\ \hline
\end{tabular}%
}
\end{table}

\paragraph{} O arquivo \textit{config.yaml} contém todos os parâmetros necessários para o funcionamento da aplicação. Os parâmetros podem ser vistos na tabela 3.1.

\subsection{View}

\paragraph{}Em aplicações que fazem uso do \textit{framework Django}, a componente \textit{view.py}, vista na figura 3.1, é responsável pelo controle e recebimento das requisições à aplicação. Essa componente é vista como um pacote da linguagem \textit{Python} e contém as funções responsáveis por enviar o HTML a ser visualizado pelo usuário e responder todas as chamadas assíncronas requisitadas pelas interfaces.

\paragraph{}É por meio dessa componente que o controle de acesso às páginas da aplicação é realizado, com o uso de decoradores especiais que restrigem o acesso a certas chamadas a depender do tipo de usuário que está acessando a aplicação. A tabela 3.2 mostra os possíveis grupos atribuídos a usuários, com suas respectivas permissões. A criação dos usuários e atribuição de  grupos está detalhada na seção 3.3. 


% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
\begin{table}[]
\centering
\caption{Possíveis grupos de usuários}
\label{access-control}
%\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|}
\hline
Grupo         & Permissões                   \\ \hline
Admin         & Acesso às views Monitor, Disparo e Showroom \\ \hline
DispatchUser  & Acesso à view Disparo        \\ \hline
ShowroomUser  & Acesso à view Showroom       \\ \hline
\end{tabular}%
%}
\end{table}

\subsection{Datalake}

\paragraph{} A componente \textit{datalake.py} é responsável pela conexão com o \textit{datalake} que contém os dados sobre os quais serão feitas as inferências do modelo carregado na componente \textit{daemon.py}. A tabela 3.3 contém a descrição de os métodos dessa componente. Os métodos refletem essencialmente o uso básico de um conector ODBC, requerendo uma cadeia de conexão adequada ao serviço empregado pelo \textit{datalake}.

\paragraph{}

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
\begin{table}[]
\centering
\caption{Métodos do componente \textit{datalake.py}.}
\label{datalake}
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|}
\hline
Método     & Descrição                                                                    \\ \hline
connect    & Inicializa a conexão com o banco de dados usando a cadeia de conexão provida \\ \hline
disconnect & Fecha a conexão com o banco de dados                                         \\ \hline
execute    & Executa uma query SQL, retornando seu resultado                                \\ \hline
\end{tabular}%
}
\end{table}

\subsection{Showroom}

\paragraph{}A \textit{view Showroom} é caracterizada pela existência de casos sobre os quais serão inferidas classificações a partir do modelo de aprendizado de máquina carregado na aplicação. Toda execução gerada a partir dessa \textit{view} segue os passos vistos no diagrama de sequência apresentado na figura 3.4. Os dados para a predição são coletados, o evento é registrado na tabela de log de eventos, o resultado é computado e a \textit{view} é atualizada com os resultados da predição. A tabela de eventos, por sua vez, é populada por eventos relacionados a cada execução, representados pelas colunas da entidade \textit{ShowroomDispatch} na figura 3.3. Os dois métodos da componente \textit{showroom.py} podem ser vistos na tabela 3.4.

\paragraph{}Os dois métodos representam dois casos de uso possíveis. O primeiro se trata de quando a \textit{view} é inicializada e todos os casos são inferidos, fazendo uso do método \textit{predict\_all}, o segundo se trata da inferência de apenas um dos casos assincronamente, fazendo uso do método \textit{predict\_one}.

\begin{table}[]
\centering
\caption{Métodos do componente \textit{showroom.py}.}
\label{showroom}
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|}
\hline
Método       & Descrição                                                                                                                                                                                               \\ \hline
predict\_all & \begin{tabular}[c]{@{}l@{}}Retorna o resultado das predições para todos os casos (linhas) presentes no arquivo \\ indicado pelo caminho 'samples\_path' contido no arquivo de configuração\end{tabular} \\ \hline
predict\_one & Faz o mesmo que predict\_all, porém apenas para a linha 'id' do arquivo 'samples\_path'                                                                                                                 \\ \hline
\end{tabular}%
}
\end{table}

\begin{figure}
\begin{center}
\parbox[htb]{13.0cm}
  {
  \begin{center}
  \includegraphics[scale=0.50]{ERD.png}
  \caption[\small{Diagrama Entidade-Relacionamento do banco.}]{\label{FigDel} \small{Diagrama Entidade-Relacionamento do banco.}}
  \end{center}
  }
\end{center}
\end{figure}

\begin{figure}
\begin{center}
\parbox[htb]{13.0cm}
  {
  \begin{center}
  \includegraphics[scale=0.30]{sequence_showroom.png}
  \caption[\small{Diagrama de sequência da \textit{view Showroom}.}]{\label{FigDel} \small{Diagrama de sequência da \textit{view Showroom}.}}
  \end{center}
  }
\end{center}
\end{figure}

\subsection{Daemon}

\paragraph{}A componente \textit{daemon.py} se trata do \textit{script Python} responsável pelos disparos cuja execução é gerenciada pela aplicação por meio do arquivo \textit{crontab}. A componente contém apenas um método, o \textit{execute}, que é responsável por executar a predição de todos os casos disponíveis no \textit{datalake}. Sua execução segue os passos do diagrama de sequência visto na figura 3.5. Inicialmente um novo disparo é inicializado e o evento de inicialização é armazenado no banco da aplicação, o modelo de inferência é carregado para memória da aplicação, as ocorrências a sofrerem o processo preditivo são coletadas do \textit{datalake} e o evento de coleta é registrado. Após isso as predições são realizadas e seus resultados são registrados no banco da aplicação. Posteriormente, os resultados são salvos no \textit{datalake} e o evento de inserção é salvo. Por fim, o evento de finalização é armazenado.

\paragraph{}O disparo, os eventos e os resultados das predições das ocorrências são armazenados no banco da aplicação fazendo uso das entidades observadas na figura 3.3.

\begin{figure}
\begin{center}
\parbox[htb]{13.0cm}
  {
  \begin{center}
  \includegraphics[scale=0.30]{sequence_daemon.png}
  \caption[\small{Diagrama de sequência da componente \textit{daemon.py}.}]{\label{FigDel} \small{Diagrama de sequência da \textit{view Showroom}.}}
  \end{center}
  }
\end{center}
\end{figure}

\subsection{Disparo}

\paragraph{} A \textit{view Disparo} é responsável por permitir a visualização dos disparos executados, onde cada disparo é dado pela execução do script de inferência. Nela é possível visualizar todos os disparos executados pela componente \textit{daemon.py} a partir de um filtro temporal. Todos os resultados de todas as predições dentro do intervalo temporal selecionado são visualizados em tabelas, uma tabela para cada disparo. Os métodos dessa componente podem ser vistos na tabela 3.5, referente à componente dispatch.py.

\begin{table}[]
\centering
\caption{Métodos do componente \textit{dispatch.py}.}
\label{dispatch}
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|}
\hline
Método                        & Descrição                                                                                                                                                                                       \\ \hline
get\_dispatch\_events         & Retorna todos os eventos relacionados ao disparo com id igual ao fornecido                                                                                                                      \\ \hline
get\_dispatch\_predictions    & \begin{tabular}[c]{@{}l@{}}Retorna todos os resultados de predições relacionados ao disparo com id igual \\ ao fornecido\end{tabular}                                                           \\ \hline
get\_dispatches\_by\_interval & Retorna todos os ids dos disparos que ocorreram dentro de um intervalo temporal                                                                                                                 \\ \hline
to\_utc                       & \begin{tabular}[c]{@{}l@{}}Converte uma cadeia de caracteres no formato de hora e data \\ yyyy-MM-ddThh:mm:ss-hh:mm para um objeto datetime na zona UTC\end{tabular}                            \\ \hline
get\_last\_dispatches         & \begin{tabular}[c]{@{}l@{}}Retorna todos os eventos e resultados de predições para todos os disparos que \\ ocorreram entre as datas start e end, agrupados pelos ids dos disparos\end{tabular} \\ \hline
\end{tabular}%
}
\end{table}

\subsection{Monitor}

\paragraph{} A \textit{view Monitor} é responsável por monitorar: o estado de um \textit{host}, o estado do banco de dados, as datas dos último e próximo disparos e o estado do escalonamento da componente \textit{daemon.py} a partir do arquivo \textit{crontab}. Em intervalos periódicos de tempo a \textit{view} é atualizada trazendo informações recentes para a interface, o que é feito por meio de uma requisição assíncrona chamada pela interface. A cada execução da atualização, os métodos \textit{get\_datalake\_status}, \textit{get\_process\_status}, \textit{get\_dispatch\_shedule}, \textit{get\_server\_status} e \textit{get\_db\_status} são executados pela componente \textit{view.py} e os resultados são enviados como resposta à requisição assíncrona, coforme visto no trecho de código a seguir. Os métodos dessa componente podem ser vistos na tabela 3.6.
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\lstset{language=Python}
\lstset{frame=lines}
%\lstset{caption={Insert code directly in your document}}
\lstset{label={lst:code_direct}}
\lstset{basicstyle=\footnotesize}
\begin{lstlisting}
def get_monitor_status(request):
    monitor = modules.Monitor()
    data = {
        'server': monitor.get_server_status(
        		settings.FRAMEWORK_CONFIG \
        		['monitor']['controller']['server']),
        'datalake': monitor.get_datalake_status(
         	settings.FRAMEWORK_CONFIG['datalake']),
        'process': monitor.get_process_status(
        		settings.FRAMEWORK_CONFIG),
        'visits': monitor.get_visits_datetimes(
        		settings.FRAMEWORK_CONFIG),
        'database': monitor.get_db_status(
        		settings.FRAMEWORK_CONFIG["mysql_events_db"])
    }
    return JsonResponse(data)
\end{lstlisting}

\paragraph{} Para a verificação do estado de um servidor, uma conexão socket é criada em uma porta aberta qualquer do host. A conexão é tida como \textit{offline} se ocorrer um timeout, sendo 10 segundos o intervalo de tempo para que isso ocorra. O host informado pode ser tanto como um endereço IPV4 quanto um endereço IPV6. Ainda é possível monitorar servidores a partir de seu nome de domínio, mudando o mecanismo configurado de \textit{plain} ou \textit{ssl} para \textit{dns}, conforme visto no parâmetro \textit{monitor.controller.server.mechanism} da tabela 3.1. O método que realiza essa verificação pode ser visto a seguir.

\hfill \break
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\lstset{language=Python}
\lstset{frame=lines}
%\lstset{caption={Insert code directly in your document}}
\lstset{label={lst:code_direct}}
\lstset{basicstyle=\footnotesize}
\begin{lstlisting}
def server_is_up(self,server):
     srv, mechanism, port = server
     try:
         if mechanism == 'plain':
             socket.create_connection(
          		(srv, port), timeout=10)
         elif mechanism == 'ssl':
             ssl.wrap_socket(
            		socket.create_connection(
            			("%s" % srv, port), timeout=10))
         elif mechanism == 'dns':
             host = socket.gethostbyname(srv)
             socket.create_connection(
            		(host, port), timeout=10)
         else:
             raise ValueError("Invalid mechanism")
         return ("online","")
     except socket.timeout:
         return ("offline","connection timeout")
     except Exception as err:
         return ("error", err.__str__())
\end{lstlisting}

\paragraph{} A verificação do estado do \textit{datalake} é feita por meio de uma conexão, usando a cadeia de conexão adequada ao banco a ser conectado. Após a conexão ser estabelecida, é realizada uma consulta simples em uma tabela qualquer pertencente ao banco, sem que nada seja retornado, com o intuito de que todos os passos da conexão sejam testados. Caso ocorra algum problema em algum momento durante a tentativa de conexão, esse problema é reportado. Essa lógica pode ser vista no trecho de código a seguir.

\hfill \break
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\lstset{language=Python}
\lstset{frame=lines}
%\lstset{caption={Insert code directly in your document}}
\lstset{label={lst:code_direct}}
\lstset{basicstyle=\footnotesize}
\begin{lstlisting}
def get_datalake_status(self, datalake_settings):
    try:
        if self.datalake is None:
            self.datalake =
            	dl.Datalake(
            		datalake_settings["connection_string"])
        table = datalake_settings["table"]
    
        self.datalake.execute(
        	'SELECT * FROM {} LIMIT 1'.format(table))
    except pyodbc.Error as err:
        print(err)
            return { 'status': "error", 'error': str(err)}
        return { 'status': "online", 'error': ''}
\end{lstlisting}

\paragraph{} O último disparo e o estado do próximo disparo são monitorados fazendo uso da biblioteca \textit{crontab} para \textit{Python 3}. Tanto a agenda de execuções quanto o comando a ser executado pelo \textit{daemon cron} são obtidos por meio do uso dessa biblioteca. A verificação do estado do comando é feita como mostrado no trecho a seguir.

\hfill \break
\lstset{language=Python}
\lstset{frame=lines}
%\lstset{caption={Insert code directly in your document}}
\lstset{label={lst:code_direct}}
\lstset{basicstyle=\footnotesize}
\begin{lstlisting}
def get_process_status(self, config):
    try:
        expr = config['daemon']['cron']
        sheduler = CronTab(user=config['daemon']['user'])
        for job in sheduler:
            if job.comment == config['daemon']['comment']:
                if not job.is_valid():
                    return {"status": "invalid", "cron": expr, "error": ""}
                if not job.is_enabled():
                    return {"status": "disabled", "cron": expr, "error": ""}
                return {"status": "active", "cron": expr, "error": ""} 
        return {"status": "inactive", "cron": expr, "error": ""}
    except Exception as e:
        return {"status": "error", "cron": expr, "error":str(e)}
\end{lstlisting}

\paragraph{}Além de monitorar os serviços associados ao \textit{framework}, a \textit{view} Monitor também é responsável pelo controle do estado do escalonamento da componente \textit{daemon.py}. Em sua interface, acessível apenas por administradores, é possível adicionar e remover o comando de execução do \textit{script daemon.py} do arquivo \textit{crontab}, efetivamente controlando se a execução ocorrerá ou não conforme previsto pela expressão CRON presente no arquivo de configuração no parâmetro \textit{daemon.cron}, visto na tabela 3.1. Esse controle é feito por meio dos métodos \textit{kill\_process} e \textit{start\_process}, vistos a seguir.

\hfill \break
\lstset{language=Python}
\lstset{frame=lines}
%\lstset{caption={Insert code directly in your document}}
\lstset{label={lst:code_direct}}
\lstset{basicstyle=\footnotesize}
\begin{lstlisting}
def kill_process(self,config):
    sheduler = CronTab(user=config['daemon']['user'])
    for job in sheduler:
        if job.comment == config['daemon']['comment']:
            sheduler.remove(job)
            sheduler.write()

def start_process(self, config):
    self.kill_process(config)
    cmd = '''{} "{}"'''.format(
    	config['daemon']['command'], config['path'])
    venv = config['daemon']['venv']
    if venv is not None and venv != "":
        cmd = "source {} ; {} ; deactivate".format(venv, cmd)
        cmd = '''"$(command -v bash)" -c '{}' '''.format(cmd)

    sheduler = CronTab(user=config['daemon']['user'])
    job = sheduler.new(command= cmd,
                        comment=config['daemon']['comment'])
    job.parse(config['daemon']['cron'])
\end{lstlisting}

\begin{table}[]
\centering
\caption{Métodos do componente \textit{monitor.py}.}
\label{monitor}
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|}
\hline
Método                  & Descrição                                                                                                                                                                             \\ \hline
get\_datalake\_status   & Retorna o estado da conexão com o datalake e o erro de conexão, se houver                                                                                                             \\ \hline
get\_process\_status    & Retorna o estado do comando gerenciado no arquivo crontab                                                                                                                             \\ \hline
get\_dispatch\_schedule & \begin{tabular}[c]{@{}l@{}}Retorna a expressão CRON usada para agendar as execuções do comando \\ gerenciado no arquivo crontab\end{tabular}                                          \\ \hline
kill\_process           & Remove o comando de execução do daemon do arquivo crontab                                                                                                                             \\ \hline
start\_process          & \begin{tabular}[c]{@{}l@{}}Inicia o agendamento do comando gerenciado no arquivo crontab, removendo\\ quaisquer comandos que possuam o mesmo id\end{tabular}                          \\ \hline
get\_server\_status     & Retorna o estado de um host, obtido a partir de conexões criadas via sockets                                                                                                          \\ \hline
get\_db\_status         & \begin{tabular}[c]{@{}l@{}}Se conecta com o banco de dados da aplicação gerenciado pelo Django e \\ retorna o estado da conexão e o erro de conexão, se houver\end{tabular}           \\ \hline
get\_visits\_datetimes  & \begin{tabular}[c]{@{}l@{}}Retorna a última e próxima data de execução para o comando gerenciado no\\ arquivo crontab, se ativo. Retorna 'N/A' para ambas caso contrário\end{tabular} \\ \hline
server\_is\_up          & \begin{tabular}[c]{@{}l@{}}Verifica se um host está online usando sockets e retorna seu estado e o erro \\ de conexão, se houver\end{tabular}                                         \\ \hline
\end{tabular}%
}
\end{table}                 

\subsection{Urls}

\paragraph{}A componente \textit{urls.py} é responsável por descrever as rotas da aplicação. Nela, os caminhos que levam às \textit{views} e às chamadas assíncronas estão detalhadas em uma lista, fazendo a associação direta entre as funções da componete \textit{views.py} e as rotas usadas pelo usuário e pela interface da aplicação. As rotas existentes podem ser vistas na tabela 3.7. As figuras 3.6, 3.7 e 3.8 mostram as interfaces acessadas pelas rotas \textit{monitor/}, \textit{dispatch/} e \textit{showroom/}, respectivamente.

\begin{figure}
\begin{center}
\parbox[htb]{13.0cm}
  {
  \begin{center}
  \includegraphics[scale=0.40]{monitor.png}
  \caption[\small{Interface da \textit{view Monitor}.}]{\label{FigDel} \small{Interface da \textit{view Monitor}.}}
  \end{center}
  }
\end{center}
\end{figure}

\begin{figure}
\begin{center}
\parbox[htb]{13.0cm}
  {
  \begin{center}
  \includegraphics[scale=0.40]{dispatch.png}
  \caption[\small{Interface da \textit{view Disparo}.}]{\label{FigDel} \small{Interface da \textit{view Disparo}.}}
  \end{center}
  }
\end{center}
\end{figure}

\begin{figure}
\begin{center}
\parbox[htb]{13.0cm}
  {
  \begin{center}
  \includegraphics[scale=0.40]{showroom.png}
  \caption[\small{Interface da \textit{view Showroom}.}]{\label{FigDel} \small{Interface da \textit{view Showroom}.}}
  \end{center}
  }
\end{center}
\end{figure}

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
\begin{table}[]
\caption{Rotas definidas na componente \textit{urls.py}.}
\label{urls}
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|}
\hline
Rota                             & Descrição                                                                                                 \\ \hline
redirect/                        & Rota de redirecionamento após o \textbackslash{}textit\{login\}                                           \\ \hline
monitor/                         & Rota para acesso à \textit{view} Monitor                                                 \\ \hline
dispatch/                        & Rota para acesso à \textit{view} Disparo                                                 \\ \hline
showroom/                        & Rota para acesso à \textit{view} Showroom                                                \\ \hline
dispatch/update\_dispatch/       & Rota para requisição assíncrona de atualização da \textit{view} Disparo                  \\ \hline
showroom/update\_showroom/       & Rota para requisição assíncrona de atualização da \textit{view} Showroom                 \\ \hline
showroom/update\_showroom\_item/ & Rota para requisição assíncrona de atualização de um dos items da \textit{view} Showroom \\ \hline
monitor/monitor\_status/         & Rota para requisição assíncrona de atualização  da \textit{view} Monitor                 \\ \hline
monitor/process\_kill/           & Rota para requisição assíncrona de remoção do comando no arquivo \textit{crontab}        \\ \hline
monitor/process\_start/          & Rota para requisição assíncrona de inserção do  comando no arquivo \textit{crontab}      \\ \hline
\end{tabular}%
}
\end{table}

\section{Implantação}

\begin{figure}
\begin{center}
\parbox[htb]{13.0cm}
  {
  \begin{center}
  \includegraphics[scale=0.50]{deployment.png}
  \caption[\small{Diagrama de implantação.}]{\label{FigDel} \small{Diagrama de implantação}}
  \end{center}
  }
\end{center}
\end{figure}

\subsection{Configuração do ambiente}

\paragraph{}Para configuração do ambiente, o primeiro passo é sua obtenção, que, para o caso da implantação desse projeto, foi obtido por meio do aluguel de um servidor da \textit{Amazon AWS}. O segundo é a obtenção do código fonte, que se encontra hospedado em um repositório do serviço \textit{Github}. Com o uso de uma conta autorizada a ter acesso ao repositório, é preciso realizar o download do projeto. A estrutura de arquivos e diretórios pode ser vista na figura 3.10, onde se encontram destacados todos os diretórios e componentes abordados nesse documento. Posteriormente, é necessário seguir as instruções presentes no arquivo \textit{README.md}, que contém detalhados todos os passos necessários para a configuração do ambiente. Estas instruções são detalhadas a seguir, para uso em um sistema operacional \textit{Linux}.

\begin{figure}
\caption[\small{Estrutura do sistema de arquivos do projeto.}]{\label{FigDel} \small{Estrutura do sistema de arquivos do projeto.}}
\begin{forest}
  for tree={
    font=\ttfamily,
    grow'=0,
    child anchor=west,
    parent anchor=south,
    anchor=west,
    calign=first,
    edge path={
      \noexpand\path [draw, \forestoption{edge}]
      (!u.south west) +(7.5pt,0) |- node[fill,inner sep=1.25pt] {} (.child anchor)\forestoption{edge label};
    },
    before typesetting nodes={
      if n=1
        {insert before={[,phantom]}}
        {}
    },
    fit=band,
    before computing xy={l=15pt},
  }
[raiz
  [default/
    [scripts/ 
		[daemon.py]
		[monitor.py]
		[dispatch.py]
		[showroom.py]
		[datalake.py]    
    ]
    [static/]
    [templates/]
    [templatetags/]
    [models.py]
    [views.py]
    [urls.py]
    [...]
  ]
  [models/]
  [manage.py]
  [settings.py]
  [requirements.txt]
  [config.yaml]
  [README.md]
  [...]
]
\end{forest}
\end{figure}

\paragraph{}Inicia-se a configuração a preparação do ambiente \textit{Python 3}, certificando-se de que a linguagem está instalada no servidor junto com o programa utilitário para criação de ambientes virtuais, o \textit{virtualenv}. Com esses passos concluídos, os próximos são inicializar o ambiente virtual, obter o código fonte e instalar as dependências. Esses passos são concluídos com os comandos abaixo.

\hfill \break
\begin{lstlisting}[language=bash]
$ # criar o diretório para o ambiente virtual  
$ mkdir myenv 
$ # obter código fonte
$ git clone https://github.com/pboueke/ml-services-framework.git
$ # criar e inicializar o ambiente virtual
$ python3 -m venv myvenv
$ source myvenv/bin/activate
(myvenv) $ # instalar dependências
(myvenv) $ cd ml-services-framework
(myvenv) $ pip install -r requirements.txt
\end{lstlisting}

\paragraph{}Em seguida, é necessária a instalação do banco de dados MySQL em um servidor acessível ao servidor da aplicação, podendo ser o mesmo servidor. Para isso, siga as instruções de instalação do banco de dados para o seu sistema operacional e, em seguida, instale no servidor da aplicação a biblioteca para conexão ao banco para clientes, a \textit{libmysqlclient-dev}. Uma vez instalado, o próximo passo é configurar o banco de dados para uso da aplicação. Se conecte localmente ao banco com o comando a seguir.

\hfill \break
\begin{lstlisting}[language=bash]
$ mysql -u USERNAME -p
\end{lstlisting}

\paragraph{}Quando conectado, execute os comandos abaixo, substituindo o termo \textit{localhost} pelo endereço apropriado ao servidor da aplicação, \textit{USERNAME} pelo nome de usuário cadastrado no serviço de banco de dados e \textit{PASSWORD} pela senha de acesso do usuário. É necessário que os dados preenchidos aqui sejam os mesmos que os preenchidos nos parâmetros \textit{mysql\_events\_db.*} do arquivo de configuração, conforme visto na tabela 3.1.

\hfill \break
\begin{lstlisting}[language=sql]
> CREATE DATABASE MLServicesFramework;
> CREATE USER 'django'@'localhost' IDENTIFIED BY 'PASSWORD';
> GRANT ALL ON MLServicesFramework.* TO 'django'@'localhost';
> FLUSH PRIVILEGES;
\end{lstlisting}

\paragraph{}Com o banco configurado, é necessário inicializar as tabelas e modelos a partir dos arquivos do \textit{framework Django}. Para alcançar esse objetivo, basta a execução dos comandos a seguir, que transformam os modelos em \textit{Python} em tabelas do banco.

\hfill \break
\begin{lstlisting}[language=bash]
$ python3 manage.py makemigrations
$ python3 manage.py migrate --database=default
$ python3 manage.py migrate --database=app_db
\end{lstlisting}

\paragraph{}Posteriormente, é preciso criar os usuários do sistema. Para isso, executa-se o comando a seguir para criar um usuário administrador e inicia-se a aplicação para criação dos demais usuários e grupos. Com a aplicação rodando localmente é feito o acesso à interface de administração de grupos do \textit{Django}, \textit{http://127.0.0.1:8000/adm- in/auth/group/add/}, e são criados os dois grupos, \textit{DispatchUser} e \textit{ShowroomUser}, vistos na tabela 3.2. Usuários podem, então, ser criados pela interface de administração de usuários do \textit{Django}, \textit{http://127.0.0.1:8000/admin/auth/user/add/}, e atribuídos aos grupos existentes conforme a necessidade de cada um.

\hfill \break
\begin{lstlisting}[language=bash]
$ # criar um usuário administrador
$ python3 manage.py createsuperuser
$ # inicia a aplicação na porta padrão
$ python3 manage.py runserver
\end{lstlisting}

\paragraph{}Para a conexão com o \textit{datalake}, é necessária a instalação no servidor da aplicação do conector ODBC relativo ao tipo de banco de dados usado por ele. Primeiramente instale os pacotes \textit{unixodbc-dev}, \textit{unixodbc-bin} e \textit{unixodbc} e prossiga para a instalação do \textit{driver} relativo ao banco de dados específico. Note que o \textit{datalake} precisa ter uma interface ODBC, ou ele não será compatível com o  projeto.

\paragraph{}Por fim, é necessária a configuração do arquivo \textit{config.yaml}, como visto na tabela 3.1. É necessária a revisão de todos os caminhos apontados pelo arquivo, assim como dados de conexão aos bancos de dados e servidores monitorados.

\subsection{Inicialização da aplicação}

\paragraph{}Para a inicialização do projeto, basta a ativaçãodo ambiente virtual e execução do comando de inicialização, com a especificação da porta desejada, coforme visto abaixo.

\hfill \break
\begin{lstlisting}[language=bash]
$ # inicializar o ambiente virtual  
$ source myvenv/bin/activate
$ # inicializar a aplicação
(myenv) $ python3 manage.py runserver <seu_ip:<porta>
\end{lstlisting}
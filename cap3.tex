\section{Arquitetura}

\paragraph{}O projeto desenvolvido se trata de uma aplicação \textit{Django} que conta com três interfaces, uma para execução de um modelo preditivo em ocorrências controladas, outra para monitoramento dos serviços associados e outra para a visualização dos resultados das predições, chamadas, respectivamente, de \textit{Showroom}, \textit{Monitor} e \textit{Disparo}. Essas três interfaces são controladas pela aplicação por meio de três classes, vistas na figura 3.1. Os componentes da aplicação podem ser visualizados na figura 3.2, onde se observa a existência de um arquivo \textit{config.yaml}, responsável por agregar todos os parâmetros e configurações da aplicação.

Além da aplicação, existem as componentes \textit{daemon.py} e \textit{datalake.py} que são responsáveis, respectivamente, pela predição de resultados e conexão com o \textit{datalake} onde estão os dados a sofrerem predições. O escalonamento de predições é gerenciado pelo \textit{crontab}, que, por sua vez, é gerenciado pela aplicação.


\section{Implementação}

\paragraph{} No modelo seguido pelo \textit{framework Django}, o modelo \textit{MTV}, todas as páginas e interfaces da aplicação são renderizadas a partir de templates HTML preenchidos pelo controlador da aplicação, que no caso se trata do arquivo \textit{views.py}. Os templates HTML se encontram dentro do diretório \textit{templates}. Os modelos se encontram no arquivo \textit{models.py}, fazendo uso direto das classes de modelo do \textit{framework}. As rotas da aplicação se encontram no arquivo \textit{urls.py}. As componentes \textit{monitor.py}, \textit{showroom.py}, \textit{dispatch.py}, \textit{datalake.py} e \textit{daemon.py} se encontram no diretório \textit{scripts}.

\begin{figure}
\begin{center}
\parbox[htb]{13.0cm}
  {
  \begin{center}
  \includegraphics[scale=0.5]{framework_clases.png}
  \caption[\small{Diagrama de classes da aplicação.}]{\label{FigDel} \small{Diagrama de classes da aplicação.}}
  \end{center}
  }
\end{center}
\end{figure}

\begin{figure}
\begin{center}
\parbox[htb]{13.0cm}
  {
  \begin{center}
  \includegraphics[scale=0.50]{framework.png}
  \caption[\small{Diagrama de componentes da aplicação.}]{\label{FigDel} \small{Diagrama de componentes da aplicação.}}
  \end{center}
  }
\end{center}
\end{figure}

\subsection{Configuração}

\paragraph{}Toda a configuração da aplicação é feita a partir de dois arquivos, o \textit{settings.py} e o \textit{config.yaml}. No primeiro são configuradas as propriedades básicas de uma aplicação \textit{Django}, se tratando de seu arquivo de configuração padrão. No segundo, estão as configurações específicas a essa aplicação. O caminho ao arquivo \textit{config.yaml} é escrito como a variável \textit{CONFIG\_FILE}, dentro do arquivo \textit{settings.py}, para que as configurações possam ser carregadas na aplicação durante sua inicialização.

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
\begin{table}[]
\caption{Parâmetros de configuração contidos no arquivo \textit{config.yaml}.}
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|}
\hline
Parâmetro                                   & Descrição                                                                                                                                                                                     \\ \hline
monitor.controllerserver.address            & Endereço (ip ou nome de domínio) para o servidor monitorado                                                                                                                                   \\ \hline
monitor.controller.server.machanism         & \begin{tabular}[c]{@{}l@{}}Mecanismo de conexão  com o servidor monitorado (plain ou ssl para ips,\\  dns para nomes de domínio)\end{tabular}                                                 \\ \hline
monitor.controller.server.port              & Porta de conexão com o servidor monitorado(apenas para ips)                                                                                                                                   \\ \hline
monitor.view.refresh\_rate                  & Segundos entre atualizações das informaçoes na view monitor                                                                                                                                   \\ \hline
dispatch.view.filter.default\_offset        & Diferença temporal padrão para o filtro de disparos                                                                                                                                           \\ \hline
showroom.controller.max\_min\_model\_path   & Arquivo de modelo usado para pré-tratamento das amostras                                                                                                                                      \\ \hline
showroom.controller.prediction\_model\_path & Arquivo de modelo usado para a predição dos resultados                                                                                                                                        \\ \hline
showroom.controller.samples\_path           & Arquivo contendo amostras em formato csv                                                                                                                                                      \\ \hline
showroom.controller.number\_of\_columns     & Número de colunas entre as primeiras do arquivo a serem mostradas na view                                                                                                                     \\ \hline
mysql\_events\_db.name                      & Nome do banco de eventos                                                                                                                                                                      \\ \hline
mysql\_events\_db.user                      & Nome do usuário do banco de dados                                                                                                                                                             \\ \hline
mysql\_events\_db.password                  & Senha do usuário do banco de enventos                                                                                                                                                         \\ \hline
mysql\_events\_db.host                      & Endereço do banco de eventos                                                                                                                                                                  \\ \hline
mysql\_events\_db.port                      & Porta de acesso ao banco de eventos                                                                                                                                                           \\ \hline
datalake.connection\_string                 & Cadeia de conexão ODBC para o datalake                                                                                                                                                        \\ \hline
datalake.table                              & \begin{tabular}[c]{@{}l@{}}Nome de uma tabela (qualquer tabela existente) usada para verificar a\\  conexão com o banco\end{tabular}                                                          \\ \hline
daemon.user                                 & Nome do usuário do SO                                                                                                                                                                         \\ \hline
daemon.comment                              & Comentário usado como id único para a tarefa cron                                                                                                                                             \\ \hline
daemon.cron                                 & Expressão CRON para a execução do comando                                                                                                                                                     \\ \hline
daemon.venv                                 & \begin{tabular}[c]{@{}l@{}}Caminho para a ativação do virtual environment (opcional, usado caso \\ os pacotes requeridos pelo script daemon não estejam disponíveis globalmente)\end{tabular} \\ \hline
daemon.command                              & Comando a ser executado pelo daemon cron                                                                                                                                                      \\ \hline
daemon.log\_file                            & \begin{tabular}[c]{@{}l@{}}Arquivo log de depuração - deixe em branco se não estiver debugando, \\ o log será ignorado\end{tabular}                                                           \\ \hline
\end{tabular}%
}
\end{table}

\paragraph{} O arquivo \textit{config.yaml} contém todos os parâmetros necessários para o funcionamento da aplicação. Os parâmetros podem ser vistos na tabela 3.1.

\subsection{View}

\paragraph{}Em aplicações que fazem uso do \textit{framework Django}, a componente \textit{view.py}, vista na figura 3.1, é responsável pelo controle e recebimento das requisições à aplicação. Essa componente é vista como um pacote da linguagem \textit{Python} e contém as funções responsáveis por enviar o HTML a ser visualizado pelo usuário e responder todas as chamadas assíncronas requisitadas pelas interfaces.

\paragraph{}É por meio dessa componente que o controle de acesso às páginas da aplicação é realizado, com o uso de decoradores especiais que restrigem o acesso a certas chamadas a depender do tipo de usuário que está acessando a aplicação. A tabela 3.2 mostra os possíveis grupos atribuídos a usuários, com suas respectivas permissões.

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
\begin{table}[]
\centering
\caption{Possíveis grupos de usuários}
\label{access-control}
%\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|}
\hline
Grupo         & Permissões                   \\ \hline
Admin         & Acesso a todas as interfaces \\ \hline
DispatchUser  & Acesso à view Disparo        \\ \hline
ShowroomUser  & Acesso à view Showroom       \\ \hline
\end{tabular}%
%}
\end{table}

\subsection{Datalake}

\paragraph{} A componente \textit{datalake.py} é responsável pela conexão com o \textit{datalake} que contém os dados sobre os quais serão feitas as inferências do modelo carregado na componente \textit{daemon.py}. A tabela 3.3 contém os métodos dessa componente.

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
\begin{table}[]
\centering
\caption{Métodos do componente \textit{datalake.py}.}
\label{datalake}
\begin{tabular}{|l|l|}
\hline
Método     & Descrição                                                                    \\ \hline
connect    & Inicializa a conexão com o banco de dados usando a cadeia de conexão provida \\ \hline
disconnect & Fecha a conexão com o banco de dados                                         \\ \hline
execute    & Executa a query SQL, retornando seu resultado                                \\ \hline
\end{tabular}%
\end{table}

\subsection{Showroom}

\paragraph{}A \textit{view Showroom} é caracterizada pela existência de casos sobre os quais serão inferidas classificações a partir do modelo de aprendizado de máquina carregado na aplicação. Toda execução gerada a partir dessa \textit{view} segue os passos vistos no diagrama de sequência apresentado na figura 3.4. Os dados para a predição são coletados, o evento é registrado na tabela de log de eventos, o resultado é computado e a \textit{view} é atualizada com os resultados da predição. A tabela de eventos, por sua vez, é populada por eventos relacionados a cada execução, representados pelas colunas da entidade \textit{ShowroomDispatch} na figura 3.3. Os dois métodos da componente \textit{showroom.py} podem ser vistos na tabela 3.4.

\paragraph{}Os dois métodos representam dois casos de uso possíveis. O primeiro se trata de quando a \textit{view} é inicializada e todos os casos são inferidos, fazendo uso do método \textit{predict\_all}, o segundo se trata da inferência de apenas um dos casos assíncronamente, fazendo uso do método \textit{predict\_one}.

\begin{table}[]
\centering
\caption{Métodos do componente \textit{showroom.py}.}
\label{showroom}
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|}
\hline
Método       & Descrição                                                                                                                                                                                               \\ \hline
predict\_all & \begin{tabular}[c]{@{}l@{}}Retorna o resultado das predições para todos os casos (linhas) presentes no arquivo \\ indicado pelo caminho 'samples\_path' contido no arquivo de configuração\end{tabular} \\ \hline
predict\_one & Faz o mesmo que predict\_all, porém apenas para a linha 'id' do arquivo 'samples\_path'                                                                                                                 \\ \hline
\end{tabular}%
}
\end{table}

\begin{figure}
\begin{center}
\parbox[htb]{13.0cm}
  {
  \begin{center}
  \includegraphics[scale=0.50]{ERD.png}
  \caption[\small{Diagrama Entidade-Relacionamento do banco.}]{\label{FigDel} \small{Diagrama Entidade-Relacionamento do banco.}}
  \end{center}
  }
\end{center}
\end{figure}

\begin{figure}
\begin{center}
\parbox[htb]{13.0cm}
  {
  \begin{center}
  \includegraphics[scale=0.30]{sequence_showroom.png}
  \caption[\small{Diagrama de sequência da \textit{view Showroom}.}]{\label{FigDel} \small{Diagrama de sequência da \textit{view Showroom}.}}
  \end{center}
  }
\end{center}
\end{figure}

\subsection{Daemon}

\paragraph{}A componente \textit{daemon.py} se trata do \textit{script Python} responsável pelos disparos cuja execução é gerenciada pela aplicação por meio do arquivo \textit{crontab}. A componente contém apenas um método, o \textit{execute}, que é responsável por executar a predição de todos os casos disponíveis no \textit{datalake}. Sua execução segue os passos do diagrama de sequência visto na figura 3.5. Inicialmente um novo disparo é inicializado e o evento de inicialização é armazenado no banco da aplicação, o modelo de inferência é carregado para memória da aplicação, as ocorrências a sofrerem o processo preditivo são coletadas do \textit{datalake} e o evento de coleta é registrado. Após isso as predições são realizadas e seus resultados são registrados no banco da aplicação. Posteriormente, os resultados são salvos no \textit{datalake} e o evento de inserção é salvo. Por fim, o evento de finalização é armazenado.

\paragraph{}O disparo, os eventos e os resultados das predições das ocorrências são armazenados no banco da aplicação fazendo uso das entidades observadas na figura 3.3.

\begin{figure}
\begin{center}
\parbox[htb]{13.0cm}
  {
  \begin{center}
  \includegraphics[scale=0.30]{sequence_daemon.png}
  \caption[\small{Diagrama de sequência da componente \textit{daemon.py}.}]{\label{FigDel} \small{Diagrama de sequência da \textit{view Showroom}.}}
  \end{center}
  }
\end{center}
\end{figure}

\subsection{Disparo}

\paragraph{} A \textit{view Disparo} é responsável por permitir a visualização dos disparos executados, onde cada disparo é dado pela execução do script de inferência. Nela é possível visualizar todos os disparos executados pela componente \textit{daemon.py} a partir de um filtro temporal. Todos os resultados de todas as predições dentro do intervalo temporal selecionado são visualizados em tabelas, uma tabela para cada disparo. Os métodos dessa componente podem ser vistos na tabela 3.5, referente à componente dispatch.py.

\begin{table}[]
\centering
\caption{Métodos do componente \textit{dispatch.py}.}
\label{dispatch}
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|}
\hline
Método                        & Descrição                                                                                                                                                                                       \\ \hline
get\_dispatch\_events         & Retorna todos os eventos relacionados ao disparo com id igual ao fornecido                                                                                                                      \\ \hline
get\_dispatch\_predictions    & \begin{tabular}[c]{@{}l@{}}Retorna todos os resultados de predições relacionados ao disparo com id igual \\ ao fornecido\end{tabular}                                                           \\ \hline
get\_dispatches\_by\_interval & Retorna todos os ids dos disparos que ocorreram dentro de um intervalo temporal                                                                                                                 \\ \hline
to\_utc                       & \begin{tabular}[c]{@{}l@{}}Converte uma cadeia de caracteres no formato de hora e data \\ yyyy-MM-ddThh:mm:ss-hh:mm para um objeto datetime na zona UTC\end{tabular}                            \\ \hline
get\_last\_dispatches         & \begin{tabular}[c]{@{}l@{}}Retorna todos os eventos e resultados de predições para todos os disparos que \\ ocorreram entre as datas start e end, agrupados pelos ids dos disparos\end{tabular} \\ \hline
\end{tabular}%
}
\end{table}

\subsection{Monitor}

\paragraph{} A \textit{view Monitor} é responsável por monitorar: o estado de um \textit{host}, o estado do banco de dados, as datas dos último e próximo disparos e o estado do escalonamento da componente \textit{daemon.py} a partir do arquivo \textit{crontab}. Em intervalos periódicos de tempo a \textit{view} é atualizada trazendo informações recentes para a interface. Os métodos dessa componente podem ser vistos na tabela 3.6.

\paragraph{} Para a verificação do estado de um servidor, uma conexão socket é criada em uma porta aberta qualquer do host. A conexão é tida como \textit{offline} se ocorrer um timeout, sendo 10 segundos o intervalo de tempo para que isso ocorra. O host informado pode ser tanto como um endereço IPV4 quanto um endereço IPV6. Ainda é possível monitorar servidores a partir de seu nome de domínio, mudando o mecanismo configurado de \textit{plain} ou \textit{ssl} para \textit{dns}, conforme visto no parâmetro \textit{monitor.controller.server.mechanism} da tabela 3.1.

\paragraph{} A verificação do estado do \textit{datalake} é feita por meio de uma conexão, usando a cadeia de conexão adequada ao banco a ser conectado. Após a conexão ser estabelecida, é realizada uma consulta simples em uma tabela qualquer pertencente ao banco, sem que nada seja retornado, com o intuito de que todos os passos da conexão sejam testados. Caso ocorra algum problema em algum momento durante a tentativa de conexão, esse problema é reportado.

\paragraph{} O último disparo e o estado do próximo disparo são monitorados fazendo uso da biblioteca \textit{crontab} para \textit{Python 3}. Tanto a agenda de execuções quanto o comando a ser executado pelo \textit{daemon cron} são obtidos por meio do uso dessa biblioteca.

\paragraph{}Além de monitorar os serviços associados ao \textit{framework}, a \textit{view} Monitor também é responsável pelo controle do estado do escalonamento da componente \textit{daemon.py}. Em sua interface, acessível apenas por administradores, é possível adicionar e remover o comando de execução do \textit{script daemon.py} do arquivo \textit{crontab}, efetivamente controlando se a execução ocorrerá ou não conforme previsto pela expressão CRON presente no arquivo de configuração no parâmetro \textit{daemon.cron}, visto na tabela 3.1.

\begin{table}[]
\centering
\caption{Métodos do componente \textit{monitor.py}.}
\label{monitor}
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|}
\hline
Método                  & Descrição                                                                                                                                                                             \\ \hline
get\_datalake\_status   & Retorna o estado da conexão com o datalake e o erro de conexão, se houver                                                                                                             \\ \hline
get\_process\_status    & Retorna o estado do comando gerenciado no arquivo crontab                                                                                                                             \\ \hline
get\_dispatch\_schedule & \begin{tabular}[c]{@{}l@{}}Retorna a expressão CRON usada para agendar as execuções do comando \\ gerenciado no arquivo crontab\end{tabular}                                          \\ \hline
kill\_process           & Remove o comando de execução do daemon do arquivo crontab                                                                                                                             \\ \hline
start\_process          & \begin{tabular}[c]{@{}l@{}}Inicia o agendamento do comando gerenciado no arquivo crontab, removendo\\ quaisquer comandos que possuam o mesmo id\end{tabular}                          \\ \hline
get\_server\_status     & Retorna o estado de um host, obtido a partir de conexões criadas via sockets                                                                                                          \\ \hline
get\_db\_status         & \begin{tabular}[c]{@{}l@{}}Se conecta com o banco de dados da aplicação gerenciado pelo Django e \\ retorna o estado da conexão e o erro de conexão, se houver\end{tabular}           \\ \hline
get\_visits\_datetimes  & \begin{tabular}[c]{@{}l@{}}Retorna a última e próxima data de execução para o comando gerenciado no\\ arquivo crontab, se ativo. Retorna 'N/A' para ambas caso contrário\end{tabular} \\ \hline
server\_is\_up          & \begin{tabular}[c]{@{}l@{}}Verifica se um host está online usando sockets e retorna seu estado e o erro \\ de conexão, se houver\end{tabular}                                         \\ \hline
\end{tabular}%
}
\end{table}                 

\subsection{Urls}

\paragraph{}A componente \textit{urls.py} é responsável por descrever as rotas da aplicação. Nela, os caminhos que levam às \textit{views} e às chamadas assíncronas estão detalhadas em uma lista, fazendo a associação direta entre as funções da componete \textit{views.py} e as rotas usadas pelo usuário e pela interface da aplicação.                     

\section{Implantação}

\begin{figure}
\begin{center}
\parbox[htb]{13.0cm}
  {
  \begin{center}
  \includegraphics[scale=0.50]{deployment.png}
  \caption[\small{Diagrama de implantação.}]{\label{FigDel} \small{Diagrama de implantação}}
  \end{center}
  }
\end{center}
\end{figure}

\subsection{Configuração do ambiente}

\paragraph{}Para configuraçao do ambiente, o primeiro passo é sua obtenção, que, para o caso da implantação desse projeto, foi obtido por meio do aluguel de um servidor da \textit{Amazon AWS}. O segudo é a obtenção do código fonte, que se encontra hospedado em um repositório do serviço \textit{Github}. Com o uso de uma conta autorizada a ter acesso ao repositório, é preciso realizar o download do projeto. Posteriormente, é necessário seguir as instruções presentes no arquivo \textit{README.md}, que contém detalhados todos os passos necessários para a configuração do ambiente.

\paragraph{}O primeiro é preparar o ambiente \textit{Python 3}, instalando a linguagem no servidor em que será executada a aplicação. Em seguida, é necessário criar um ambiente virtual e instalar nele todas as dependências da aplicação fazendo uso do arquivo \textit{requirements.txt}. Enfim, é preciso preparar o ambiente \textit{Django}, criando os usuários e grupos descritos no arquivo \textit{README.md}. 

\paragraph{}Após isso, é necessário instalar e configurar o banco da aplicação em algum servidor acessível ao servidor da aplicação, ou no mesmo servidor. Para isso, deve-se instalar o banco de dados MySQL, criar um usuário e \textit{database} para uso da aplicação e executar o comando do \textit{framework Django} que cria as tabelas a partir dos arquivos do projeto.

\paragraph{}Para a conexão com o \textit{datalake}, é preciso instalar o conector \textit{ODBC} compatível com o tipo de banco de dados usado pelo \textit{datalake} no servidor da aplicação. Por fim, é preciso configurar os parâmetros da aplicação contidos no arquivo \textit{config.yaml}, que se encontra no diretório raiz do projeto, conforme visto na tabela 3.1.



\subsection{Inicialização da aplicação}

\paragraph{}Para a inicialização da aplicação, basta certificar-se de que o banco da aplicação está operacional e executar o comando que inicia a  execução da aplicação \textit{Django}, conforme visto no arquivo \textit{README.md}.